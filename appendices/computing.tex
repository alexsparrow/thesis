\chapter{Computing}
\section{\susyv2}
\susyv2 is a standalone, \ac{ROOT}-based analysis framework. Analysis
scripts are written in the Python programming language. These make use of
low-level, high-performance classes written in C++. This provides a good
compromise between speed and flexibility.

The \susyv2 package has been used for a number of analyses at
\ac{CMS}. These have primarily been \ac{SUSY}-based analyses. It has also been
used for the \PW polarisation measurement as well as several other projects. The
vast majority of the initial code was written by Dr. John Jones with subsequent
contributions from a number of others.

The \susyv2 code aims to minimise the number of reads performed on a
\ac{ROOT} tree by reading branches on demand and performing lazy calculations as
required to satisfy analysis code requests for higher-level observables. The
dependency chain between calculated quantities may be viewed as a tree. The
leaves of this tree correspond to quantities stored directly in the \ac{ROOT}
file (or an alternative serialisation format). To minimise computation, each
node in this tree performs calculation (or I/O in the case of the leaf nodes)
only once. The results are then cached. Subsequent use of this quantity then
returns the cached result directly. Furthermore, access to quantities dependent
on others which have already been calculated will require the minimum necessary
calculation, reutilising cached values and minimising further \ac{I/O} or CPU
usage.

As well as the performance advantages of this approach, it has the benefit of
enforcing a kind of ``referential transparency'' -- repeated access to a given
quantity must always yield the same result (at the single-event level). Whilst
this makes certain tasks more involved -- e.g. iterative cleaning of events --
it ensures that analysis selections must ``commute'' - since they are unable to
mutate any of the quantities on which they select. This emulates some of the
benefits available in purely functional programming languages such as Haskell.

My contributions were in the maintenance and development of this code-base, the
implementation of a flexible Python-based configuration system, support for the
\ac{ROOT} \textsc{TChain} class, infrastructure for managing and monitoring
batch submissions, and the implementation of a fast ``cross-cleaner''. The
cross-cleaner must resolve ambiguties between physics objects. The detected
ambiguities may form cyclic graphs, which must be handled carefully.

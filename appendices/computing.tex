\chapter{Computing}
\section{SUSYv2}
My largest contribution to computing was in the maintenance and further
development of the \ac{SUSYv2} software package. This is a standalone
\ac{ROOT}-based analysis framework written in a mixture of C++ and Python. It
has been used in a number of analyses by the Imperial College and Friends group
within \ac{CMS}. These have primarily been \ac{SUSY}-based analyses, searching
in the 0, 1 and 2 lepton final states, photon final states. It has also been
used for the \PW polarisation measurement as well as several other projects. The
vast majority of the initial code was written by Dr. John Jones with subsequent
contributions from a number of others.

The \ac{SUSYv2} code aims to minimise the number of reads performed on a
\ac{ROOT} tree by reading branches on demand and performing lazy calculations as
required to satisfy analysis code requests for higher-level observables. The
dependency chain between calculated quantities may be viewed as a tree. The
leaves of this tree correspond to quantities stored directly in the \ac{ROOT}
file (or an alternative serialisation format). To minimise computation, each
node in this tree performs calculation (or I/O in the case of the leaf nodes)
only once and then caches the results. Subsequent access to this quantity
returns the cached result directly. Furthermore, access to quantities dependent
on quantities which have already been calculated will perform the minimum
calculation necessary, reutilising cached values and minimising further I/O or
CPU usage.

Technically this is achieved by encoding these calculational dependencies as C++
function calls between a number of functor objects. Each of these inherits from
a base class which manages caching of the calculated quantity
transparently. Implementation of a given calculation is then as simple as
writing an update method which calculates the desired quantity, accessing other
quantities as necessary, and storing the result in a pre-allocated result
cache. The framework then handles access to this cache, as well as taking care
of cache invalidation between events in the dataset.

As well as the performance advantages of this approach, it has the benefit of
enforcing a kind of referential transparency -- repeated access to a given
quantity must always yield the same result (at the single event level). Whilst
this makes certain tasks more difficult -- e.g. iterative cleaning of events -- it
ensures that cuts applied to the quantities must commute since they are not
allowed to mutate any of the quantities on which they may select. This emulates
some of the benefits available in purely functional programming languages such
as Haskell.
